<!DOCTYPE html>
<html>
  <head>
    <title>Brasov</title>
    <script type="text/javascript">
        var map;
        var myMarker;

        function initMap() {
            map = new google.maps.Map(document.getElementById("map"), {
                zoom: 19,
                center: { lat: 45.66181182861328, lng: 25.60649299621582 },
                // heading does not work on Pi unfortunately
                //heading: 95,
                disableDefaultUI: true,
                mapId: "7a3305cc7db13890",
            });
        }

        window.initMap = initMap;
    </script>

    <style>
      /* Always set the map height explicitly to define the size of the div
       * element that contains the map. */
      #map {
        height: 100%;
      }

      /* Optional: Makes the sample page fill the window. */
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      #maps-container {
        width: 800px;
        height: 480px;
      }
      #instructions {
        position: fixed;
        opacity: 0.8;
        text-align: center;
        border-radius: 5px;
        top: 10px;
        left: 20px;
        width: 760px;
        height: 60px;
        padding: 5px;
        background-color: turquoise;
        font-size: 26px;
        font-weight: bold;
        font-family: Arial, sans-serif;
        z-index: 1;
      }
      #fps-counter {
        position: fixed;
        top: 440px;
        left: 720px;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 5px;
        border-radius: 5px;
        font-family: Arial, sans-serif;
        z-index: 1;
    }
    </style>
  </head>
  <body>
    <div id="instructions">
        <span id="instruction-text">Start your engine</p>
    </div>
    <div id="fps-counter">FPS: 0</div>
    <div id="maps-container">
        <div id="map"></div>
    </div>

    <script type="text/javascript">
      // FPS Counter
      let fpsCounter = document.getElementById('fps-counter');
      let frameTimes = [];
      let lastFrameTimestamp = performance.now();

      function updateFPS() {
          let now = performance.now();
          let delta = now - lastFrameTimestamp;
          lastFrameTimestamp = now;
          
          // Keep the last 100 frame times to average
          frameTimes.push(1000 / delta);
          if (frameTimes.length > 100) {
              frameTimes.shift();
          }

          let meanFPS = frameTimes.reduce((a, b) => a + b) / frameTimes.length;
          fpsCounter.textContent = `FPS: ${Math.round(meanFPS)}`;

          requestAnimationFrame(updateFPS);
      }

      requestAnimationFrame(updateFPS);
    </script>

    <script src="https://maps.googleapis.com/maps/api/js?key=XXX&callback=initMap&v=beta"></script>
    <script src="polyline.js"></script>

    <script type="text/javascript">
      // Route instructions from backend, see decode-route.py
      const instructionsBase64 = "W3sic3RhcnRfbG9jYXRpb24iOiB7ImxhdCI6IDQ1LjY0NTk0NzQsICJsbmciOiAyNS41OTQ0MzM3fSwgImVuZF9sb2NhdGlvbiI6IHsibGF0IjogNDUuNjQ2MzQ0NCwgImxuZyI6IDI1LjU5NDU0Mzd9LCAiaHRtbF9pbnN0cnVjdGlvbnMiOiAiSGVhZCA8Yj5ub3J0aDwvYj4gb24gPGI+QnVsZXZhcmR1bCBFcm9pbG9yPC9iPiB0b3dhcmQgPGI+U3RyYWRhIE5pY29sYWUgSW9yZ2E8L2I+Lzx3YnIvPjxiPkROMUU8L2I+In0sIHsic3RhcnRfbG9jYXRpb24iOiB7ImxhdCI6IDQ1LjY0NjM0NDQsICJsbmciOiAyNS41OTQ1NDM3fSwgImVuZF9sb2NhdGlvbiI6IHsibGF0IjogNDUuNjQ2OTg0NiwgImxuZyI6IDI1LjU4OTI4NjV9LCAiaHRtbF9pbnN0cnVjdGlvbnMiOiAiVHVybiA8Yj5sZWZ0PC9iPiBvbnRvIDxiPlN0cmFkYSBOaWNvbGFlIElvcmdhPC9iPi88d2JyLz48Yj5ETjFFPC9iPiJ9LCB7InN0YXJ0X2xvY2F0aW9uIjogeyJsYXQiOiA0NS42NDY5ODQ2LCAibG5nIjogMjUuNTg5Mjg2NX0sICJlbmRfbG9jYXRpb24iOiB7ImxhdCI6IDQ1LjY0NTgyNjEsICJsbmciOiAyNS41ODk2MzR9LCAiaHRtbF9pbnN0cnVjdGlvbnMiOiAiVHVybiA8Yj5sZWZ0PC9iPiBvbnRvIDxiPlN0cmFkYSBMdW5nXHUwMTAzPC9iPi88d2JyLz48Yj5ETjFFPC9iPiJ9LCB7InN0YXJ0X2xvY2F0aW9uIjogeyJsYXQiOiA0NS42NDU4MjYxLCAibG5nIjogMjUuNTg5NjM0fSwgImVuZF9sb2NhdGlvbiI6IHsibGF0IjogNDUuNjQyODg4NCwgImxuZyI6IDI1LjU4ODgwNzh9LCAiaHRtbF9pbnN0cnVjdGlvbnMiOiAiQXQgdGhlIHJvdW5kYWJvdXQsIHRha2UgdGhlIDxiPjJuZDwvYj4gZXhpdCBvbnRvIDxiPlN0cmFkYSBNdXJlXHUwMjE5ZW5pbG9yPC9iPiJ9LCB7InN0YXJ0X2xvY2F0aW9uIjogeyJsYXQiOiA0NS42NDI4ODg0LCAibG5nIjogMjUuNTg4ODA3OH0sICJlbmRfbG9jYXRpb24iOiB7ImxhdCI6IDQ1LjY0MTg3MzksICJsbmciOiAyNS41ODgyMTF9LCAiaHRtbF9pbnN0cnVjdGlvbnMiOiAiQ29udGludWUgb250byA8Yj5QaWFcdTAyMWJhIFNmYXR1bHVpPC9iPiJ9LCB7InN0YXJ0X2xvY2F0aW9uIjogeyJsYXQiOiA0NS42NDE4NzM5LCAibG5nIjogMjUuNTg4MjExfSwgImVuZF9sb2NhdGlvbiI6IHsibGF0IjogNDUuNjQwMDk3LCAibG5nIjogMjUuNTg1MTUzM30sICJodG1sX2luc3RydWN0aW9ucyI6ICJDb250aW51ZSBvbnRvIDxiPlN0ciBHaGVvcmdoZSBCYXJpXHUwMTYzaXU8L2I+In0sIHsic3RhcnRfbG9jYXRpb24iOiB7ImxhdCI6IDQ1LjY0MDA5NywgImxuZyI6IDI1LjU4NTE1MzN9LCAiZW5kX2xvY2F0aW9uIjogeyJsYXQiOiA0NS42Mzk4MTE4LCAibG5nIjogMjUuNTg1MjU0NH0sICJodG1sX2luc3RydWN0aW9ucyI6ICJBdCB0aGUgcm91bmRhYm91dCwgdGFrZSB0aGUgPGI+M3JkPC9iPiBleGl0In0sIHsic3RhcnRfbG9jYXRpb24iOiB7ImxhdCI6IDQ1LjYzOTgxMTgsICJsbmciOiAyNS41ODUyNTQ0fSwgImVuZF9sb2NhdGlvbiI6IHsibGF0IjogNDUuNjM4ODg4OCwgImxuZyI6IDI1LjU4NTYwMTF9LCAiaHRtbF9pbnN0cnVjdGlvbnMiOiAiQ29udGludWUgb250byA8Yj5cdTAyMThpcnVsIEx1ZHdpZyB2YW4gQmVldGhvdmVuPC9iPiJ9LCB7InN0YXJ0X2xvY2F0aW9uIjogeyJsYXQiOiA0NS42Mzg4ODg4LCAibG5nIjogMjUuNTg1NjAxMX0sICJlbmRfbG9jYXRpb24iOiB7ImxhdCI6IDQ1LjYzOTE2NjcsICJsbmciOiAyNS41ODYzNzA0fSwgImh0bWxfaW5zdHJ1Y3Rpb25zIjogIkF0IHRoZSByb3VuZGFib3V0LCB0YWtlIHRoZSA8Yj4xc3Q8L2I+IGV4aXQgb250byA8Yj5TdHJhZGEgUG9hcnRhIFNjaGVpPC9iPjxkaXYgc3R5bGU9XCJmb250LXNpemU6MC45ZW1cIj5EZXN0aW5hdGlvbiB3aWxsIGJlIG9uIHRoZSByaWdodDwvZGl2PiJ9LCB7InN0YXJ0X2xvY2F0aW9uIjogeyJsYXQiOiA0NS42MzkxNjY3LCAibG5nIjogMjUuNTg2MzcwNH0sICJlbmRfbG9jYXRpb24iOiB7ImxhdCI6IDQ1LjYzOTY0NjMsICJsbmciOiAyNS41ODc0OTk4fSwgImh0bWxfaW5zdHJ1Y3Rpb25zIjogIkhlYWQgPGI+bm9ydGhlYXN0PC9iPiBvbiA8Yj5TdHJhZGEgUG9hcnRhIFNjaGVpPC9iPiB0b3dhcmQgPGI+U3RyYWRhIEdlb3JnZSBDb1x1MDIxOWJ1YzwvYj4ifSwgeyJzdGFydF9sb2NhdGlvbiI6IHsibGF0IjogNDUuNjM5NjQ2MywgImxuZyI6IDI1LjU4NzQ5OTh9LCAiZW5kX2xvY2F0aW9uIjogeyJsYXQiOiA0NS42Mzk0NTA5LCAibG5nIjogMjUuNTg3NzQ0OX0sICJodG1sX2luc3RydWN0aW9ucyI6ICJUdXJuIDxiPnJpZ2h0PC9iPjxkaXYgc3R5bGU9XCJmb250LXNpemU6MC45ZW1cIj5SZXN0cmljdGVkIHVzYWdlIHJvYWQ8L2Rpdj4ifSwgeyJzdGFydF9sb2NhdGlvbiI6IHsibGF0IjogNDUuNjM5NDUwOSwgImxuZyI6IDI1LjU4Nzc0NDl9LCAiZW5kX2xvY2F0aW9uIjogeyJsYXQiOiA0NS42Mzk2NDYzLCAibG5nIjogMjUuNTg3NDk5OH0sICJodG1sX2luc3RydWN0aW9ucyI6ICJIZWFkIDxiPm5vcnRod2VzdDwvYj4gdG93YXJkIDxiPlN0cmFkYSBQb2FydGEgU2NoZWk8L2I+PGRpdiBzdHlsZT1cImZvbnQtc2l6ZTowLjllbVwiPlJlc3RyaWN0ZWQgdXNhZ2Ugcm9hZDwvZGl2PiJ9LCB7InN0YXJ0X2xvY2F0aW9uIjogeyJsYXQiOiA0NS42Mzk2NDYzLCAibG5nIjogMjUuNTg3NDk5OH0sICJlbmRfbG9jYXRpb24iOiB7ImxhdCI6IDQ1LjY0MDYwOTYsICJsbmciOiAyNS41ODk3ODcyfSwgImh0bWxfaW5zdHJ1Y3Rpb25zIjogIlR1cm4gPGI+cmlnaHQ8L2I+IG9udG8gPGI+U3RyYWRhIFBvYXJ0YSBTY2hlaTwvYj4ifSwgeyJzdGFydF9sb2NhdGlvbiI6IHsibGF0IjogNDUuNjQwNjA5NiwgImxuZyI6IDI1LjU4OTc4NzJ9LCAiZW5kX2xvY2F0aW9uIjogeyJsYXQiOiA0NS42NDEzNTYzLCAibG5nIjogMjUuNTkxMDk5N30sICJodG1sX2luc3RydWN0aW9ucyI6ICJDb250aW51ZSBvbnRvIDxiPlN0cmFkYSBHcmlnb3JhXHUwMjE5IERpbmljdTwvYj4ifSwgeyJzdGFydF9sb2NhdGlvbiI6IHsibGF0IjogNDUuNjQxMzU2MywgImxuZyI6IDI1LjU5MTA5OTd9LCAiZW5kX2xvY2F0aW9uIjogeyJsYXQiOiA0NS42NDM2MTYxLCAibG5nIjogMjUuNTk3MDgxfSwgImh0bWxfaW5zdHJ1Y3Rpb25zIjogIjxiPlN0cmFkYSBHcmlnb3JhXHUwMjE5IERpbmljdTwvYj4gdHVybnMgPGI+cmlnaHQ8L2I+IGFuZCBiZWNvbWVzIDxiPlN0cmFkYSBOaWNvbGFlIEJcdTAxMDNsY2VzY3U8L2I+In0sIHsic3RhcnRfbG9jYXRpb24iOiB7ImxhdCI6IDQ1LjY0MzYxNjEsICJsbmciOiAyNS41OTcwODF9LCAiZW5kX2xvY2F0aW9uIjogeyJsYXQiOiA0NS42NDMyNzM2OTk5OTk5OSwgImxuZyI6IDI1LjU5NzUyNDl9LCAiaHRtbF9pbnN0cnVjdGlvbnMiOiAiVHVybiA8Yj5yaWdodDwvYj4gb250byA8Yj5TdHJhZGEgQ29uc3RhbnRpbiBEb2Jyb2dlYW51LUdoZXJlYTwvYj4ifSwgeyJzdGFydF9sb2NhdGlvbiI6IHsibGF0IjogNDUuNjQzMjczNjk5OTk5OTksICJsbmciOiAyNS41OTc1MjQ5fSwgImVuZF9sb2NhdGlvbiI6IHsibGF0IjogNDUuNjQxMDAzOCwgImxuZyI6IDI1LjU5Mjc0Mjh9LCAiaHRtbF9pbnN0cnVjdGlvbnMiOiAiVHVybiA8Yj5yaWdodDwvYj4gb250byA8Yj5TdHJhZGEgQ2FzdGVsdWx1aTwvYj4ifSwgeyJzdGFydF9sb2NhdGlvbiI6IHsibGF0IjogNDUuNjQxMDAzOCwgImxuZyI6IDI1LjU5Mjc0Mjh9LCAiZW5kX2xvY2F0aW9uIjogeyJsYXQiOiA0NS42NDAyMjYsICJsbmciOiAyNS41OTM0Nzd9LCAiaHRtbF9pbnN0cnVjdGlvbnMiOiAiVHVybiA8Yj5sZWZ0PC9iPiBvbnRvIDxiPlN0cmFkYSBTdWlcdTAyMTl1bCBDYXN0ZWx1bHVpPC9iPiJ9XQ==";
      const decodedInstructions = JSON.parse(atob(instructionsBase64));
      //console.log(decodedInstructions);

      // Polyline from backend, see decode-route.py      
      const routePolylineBase64 = "ZWZydUdlfGV7Q2FBUUtDQVZvQX5QWWBFVWJGQFpiQE16Q2NBVkRQTERGSEhMQk5FTE12QE9mQlhqQEpwRGhBdERwQWhCeEB4QGZAfEB+QGJBdEFqQGhBZEFkQ3RBfkRWfEA/TEJKRERIP0RFREdGU1BRbkNhQWpAQ0BBRENESz9PRU1JRUlAU2dAcUB3QmlBZ0RmQG9AZ0BuQGNBdUN3QmVIcUBpRE9hQFFRZUF1QGdAe0RpQGtDYUFzRGdDX0txQHVCYUJjRFNVXmVAZEBxQGpBYEJsQG5AWmJAXHRAbEByQ2pCfEh8QGxDakByQUxaXFt6QHdAfkBfQQ==";
      const decodedPolyline = polyline.decode(atob(routePolylineBase64), 5);

      // Google needs named objects
      let latLngPolyline = decodedPolyline.map(function(coord) {
        return { lat: coord[0], lng: coord[1] };
      });

      let myPolyline = new google.maps.Polyline({
          path: latLngPolyline,
          geodesic: true,
          strokeColor: '#0031FF',
          strokeOpacity: 0.5,
          strokeWeight: 10
      });

      myPolyline.setMap(map);

      const startPosition = new google.maps.LatLng(45.66185,25.6065);

      myMarker = new google.maps.Marker({
          position: startPosition,
          map: map,
          icon: {
            url: 'arrow_shadow.png',
            size: new google.maps.Size(42, 42), 
            anchor: new google.maps.Point(22, 20),
            optimized: false
          }
      });

      // Center the map slightly at the bottom
      let newVerticalCenter = startPosition.lng() + 0.0002;
      map.setCenter(new google.maps.LatLng(startPosition.lat(), newVerticalCenter));

      function adjustMapCenterWithHeading(map, startPosition, heading, offset) {
          // Convert heading to radians
          let headingRadians = heading * (Math.PI / 180);

          // Calculate offsets based on heading
          let latOffset = offset * Math.cos(headingRadians); // Latitude offset
          let lngOffset = offset * Math.sin(headingRadians); // Longitude offset

          // Calculate new center coordinates
          let newLat = startPosition.lat + latOffset;
          let newLng = startPosition.lng + lngOffset;

          // Set the new center of the map
          map.setCenter(new google.maps.LatLng(newLat, newLng));
      }

      // Calculate distance between two coordiates
      function haversineDistance(coords1, coords2, isMiles = false) {
        function toRad(x) {
            return x * Math.PI / 180;
        }

        var R = 6371; // Earth radius in km
        var dLat = toRad(coords2.lat - coords1.lat);
        var dLon = toRad(coords2.lng - coords1.lng);
        var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(toRad(coords1.lat)) * Math.cos(toRad(coords2.lat)) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        var distance = R * c;

        return isMiles ? distance * 0.621371 : distance;
      
      }

      function findClosestLeg(position, routeDetails) {
        let closestLeg = null;
        let smallestDistance = Number.MAX_VALUE;

        routeDetails.forEach(leg => {
            // Calculate distance to the end point of the leg
            const distanceToStart = haversineDistance(position, leg.start_location);

            // Update closest leg if this leg's end is closer
            if (distanceToStart < smallestDistance) {
                smallestDistance = distanceToStart;
                closestLeg = leg;
            }
        });

        return closestLeg;
      }



      // Bearing is needed for the correct direction/angle of the arrow
      function degreesToRadians(degrees) {
        return degrees * Math.PI / 180;
      }

      function radiansToDegrees(radians) {
        return radians * 180 / Math.PI;
      }

      function calculateBearing(startLat, startLng, destLat, destLng) {
        const startLatRad = degreesToRadians(startLat);
        const startLngRad = degreesToRadians(startLng);
        const destLatRad = degreesToRadians(destLat);
        const destLngRad = degreesToRadians(destLng);

        const y = Math.sin(destLngRad - startLngRad) * Math.cos(destLatRad);
        const x = Math.cos(startLatRad) * Math.sin(destLatRad) -
                Math.sin(startLatRad) * Math.cos(destLatRad) * Math.cos(destLngRad - startLngRad);
        
        const bearing = radiansToDegrees(Math.atan2(y, x));
        return (bearing + 360) % 360; // Normalize to 0-360 degrees
      }

      // Driving simulation
      // First, interpolate route to make it more granular
      // helper to generate more GPS coordinates then there actually are
      function interpolateGpsCoordinates(points, targetLength) {
          const interpolatedPoints = [];
          const totalOriginalPoints = points.length;
          const intervals = targetLength / (totalOriginalPoints - 1);

          for (let i = 0; i < totalOriginalPoints - 1; i++) {
              const start = points[i];
              const end = points[i + 1];

              for (let j = 0; j < intervals; j++) {
                  const lat = start.lat + (end.lat - start.lat) * (j / intervals);
                  const lng = start.lng + (end.lng - start.lng) * (j / intervals);
                  interpolatedPoints.push({ lat, lng });
              }
          }

          // Make sure to add the last point of the original array
          interpolatedPoints.push(points[points.length - 1]);

          return interpolatedPoints;
      }

      const simulatedRoute = interpolateGpsCoordinates(latLngPolyline, 5000);

      // Now move forward in defined interval
      let step = 0;
      const timeInterval = 75; // Duration in milliseconds between each step

      // Function to move the marker
      function moveMarker() {
          if (step < simulatedRoute.length - 1) {
              var currentPos = simulatedRoute[step];
              var nextPos = simulatedRoute[step + 1];
              
              // Heading seems unsupported in Chromium on Raspberry Linux
              //var heading = google.maps.geometry.spherical.computeHeading(currentPos, nextPos);
              //map.setHeading(heading);
              map.setCenter(currentPos);
              myMarker.setPosition(currentPos);

              // Update marker direction
              let angle = calculateBearing(currentPos.lat, currentPos.lng, nextPos.lat, nextPos.lng);
              const markerImage = document.querySelector('img[src="arrow_shadow.png"]');
              if(markerImage) {
                markerImage.style.transform = "rotate(" + angle + "deg)";
              }

              // Update navigation instruction for the next turn
              let closestLeg = findClosestLeg(currentPos, decodedInstructions);
              document.getElementById("instruction-text").innerHTML = closestLeg.html_instructions;

              // Position the map so it points "north" all the time
              // This does not work on Zero 2 Chromium, maybe for resource reasons
              //adjustMapCenterWithHeading(map, currentPos, heading, 0.0002);

              step++;
          } else {
              clearInterval(interval); // Stop the simulation once the end of the array is reached
          }
      }

      // Start the simulation
      var interval = setInterval(moveMarker, timeInterval);
    </script>

  </body>
</html>